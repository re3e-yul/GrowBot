#!/usr/bin/python
import io # used to create file streams
import fcntl # used to access I2C parameters like addresses
import time # used for sleep delay and timestamps
import os
import sys
import time
import datetime
import threading
import MySQLdb
import RPi.GPIO as GPIO

global default_address
global date
global Lights
global AirPump
global WaterPump
global period
global Level
global mode
global pH
global LampTemp
global SoilTemp
global LastFlood
global NextFlood
global Light

class Sensor():
    	long_timeout = 1.5 # the timeout needed to query readings and calibrations
    	short_timeout = .5 # timeout for regular commands
#    	default_bus = 1 # the default bus for I2C on the newer Raspberry Pis, certain older boards use bus 0
#	default_address = 99 # the default address for the pH sensor
    	def __init__(self, address, bus):
       		# open two file streams, one for reading and one for writing
        	# the specific I2C channel is selected with bus it is usually 1, except for older revisions where its 0 wb and rb indicate binary read and write
        	self.file_read = io.open("/dev/i2c-" + str(bus), "rb", buffering=0)
        	self.file_write = io.open("/dev/i2c-" + str(bus), "wb", buffering=0)
        	# initializes I2C to either a user specified or default address
        	self.set_i2c_address(address)
    	def set_i2c_address(self, addr):
        	# set the I2C communications to the slave specified by the address
        	0 # The commands for I2C dev using the ioctl functions are specified in
        	# the i2c-dev.h file from i2c-tools
        	I2C_SLAVE = 0x703
        	fcntl.ioctl(self.file_read, I2C_SLAVE, addr)
        	fcntl.ioctl(self.file_write, I2C_SLAVE, addr)

    	def write(self, string):
        	# appends the null character and sends the string over I2C
        	string += "\00"
        	self.file_write.write(string)
    	def read(self, num_of_bytes=31):
       		# reads a specified number of bytes from I2C, then parses and displays the result
        	res = self.file_read.read(num_of_bytes) # read from the board
        	response = filter(lambda x: x != '\x00', res) # remove the null characters to get the response
        	if (ord(response[0]) == 1): # if the response isnt an error
            		char_list = map(lambda x: chr(ord(x) & ~0x80), list(response[1:])) # change MSB to 0 for all received characters except the first and get a list of characters
            		# NOTE: having to change the MSB to 0 is a glitch in the raspberry pi, and you shouldn't have to do this!
            		return ''.join(char_list) # convert the char list to a string and returns it
        	else:
            		return "Error " + str(ord(response[0]))
    	def query(self, string):
        	# write a command to the board, wait the correct timeout, and read the response
        	self.write(string)
        	# the read and calibration commands require a longer timeout
        	if ((string.upper().startswith("R")) or
                	(string.upper().startswith("CAL"))):
            		time.sleep(self.long_timeout)
        	elif ((string.upper().startswith("SLEEP"))):
            		return "sleep mode"
        	else:
            		time.sleep(self.short_timeout)
        	return self.read()
    	def close(self):
        	self.file_read.close()
        	self.file_write.close()

def readDB():
	global date
	global Temp
	global pH	
	global EV
	global TDS
	global Salt
	global SG
	global LastFlood
	global NextFlood
	global period
	global LastpHCal
	global NextpHCal
	global Vol
	global lights
	global ExFan
	global AirPump
	global WaterPump
	global Drain
	global Level
	global mode
	global LampTemp
	global SoilTemp

        conn = MySQLdb.connect(host="localhost", user="pi", passwd="a-51d41e", db="Farm")
        cursor = conn.cursor()
        cursor.execute('select date, Temp, pH, EV, TDS, Salt, SG from H2O order by date desc limit 1');
        data = cursor.fetchall()
        for row in data :
                date = row[0]
		Temp = row[1]
		pH = row[2]
		EV= row[3]
		TDS = row[4]
		Salt = row[5]
		SG = row[6]

	cursor.execute('select date, LastFlood, NextFlood, period, LastpHCal, NextpHCal, Vol from farmSched order by date desc limit 1');
        data = cursor.fetchall()
	for row in data :
                date = row[0]
                LastFlood = row[1]
                NextFlood = row[2]
		period = row[3]
		LastpHCal = row[4]
		NextpHCal = row[5]
		Vol = row[6]

	cursor.execute('select date, lights, ExFan, AirPump, WaterPump, Drain, Level, mode, LampTemp, SoilTemp from farmdata order by date desc limit 1');
        data = cursor.fetchall()
        for row in data :
                date = row[0]
                lights = row[1]
                ExFan = row[2]
                AirPump = row[3]
                WaterPump = row[4]
                Drain = row[5]
                Level = row[6]
		mode = row[7]
		LampTemp = row[8]
		SoilTemp = row[9]
        cursor.close ()
	
	conn.close ()

 	return date, Temp, pH, EV, TDS, Salt, SG, LastFlood, NextFlood, period, LastpHCal, NextpHCal, Vol, lights, ExFan, AirPump, WaterPump, Drain, Level, mode, LampTemp, SoilTemp


def WriteDB(LastFlood, NextFlood, period, LastpHCal, NextpHCal, Vol):

        date = strftime("%Y-%m-%d %H:%M:%S", gmtime())
        conn = MySQLdb.connect(host="localhost", user="pi", passwd="a-51d41e", db="Farm")
        cursor = conn.cursor()

        try:
                cursor.execute("""INSERT INTO farmSched VALUES (%s,%s,%s,%s,%s,%s,%s)""",(date,LastFlood,NextFlood,period,LastpHCal,NextpHCal,Vol))
                conn.commit()
        except Exception, e:
                print str(e) 
                conn.rollback()

        finally:
                print date,LastFlood,NextFlood,period,LastpHCal,NextpHCal,Vol

        cursor.close ()
        conn.close()


def LightIt(TurnOn, TurnOff):
        now = datetime.datetime.now()
        Light = 18
        if (now >= TurnOn and now <= TurnOff):
                GPIO.output(Light, GPIO.HIGH)
#		print now, "on"
        else:
                GPIO.output(Light, GPIO.LOW)
#               print now, "off"

def WaterIt(Level, period, NextFlood):
	print "in WaterIt"
	now = str(datetime.datetime.now())
	NextFlood = str(NextFlood) 
	if (now > NextFlood):
		print ""
		GPIO.output(BedEnable.HIGH)
		GPIO.output(BedSelect.LOW)
		GPIO.output(Pump, GPIO.HIGH)

def DrainIt(channel):
  	# Called if sensor output changes
  	global vol
  	timestamp = time.time()
  	stamp = datetime.datetime.fromtimestamp(timestamp).strftime('%H:%M:%S')
  	if GPIO.input(channel):
  		vol -= vol

	return vol


def AerateIt():
        now = datetime.datetime.now()
        minutes = now.minute
        lastdigit = int(repr(minutes)[-1])
        Air = 14
        if ( lastdigit > 6):
                GPIO.output(Air, GPIO.LOW)
        else:
                GPIO.output(Air, GPIO.HIGH)

#######################################################################################
##                                                                                   ##
##                                     MAIN                                          ##   
##                                                                                   ##
#######################################################################################
now = datetime.datetime.now()
if len(sys.argv) > 1:
        for arg in sys.argv:

                if arg == "-f" or arg == "-F":
                        mode = "Flowering"
                        TurnOn = now.replace(hour=8, minute=00, second=0)
                       TurnOff = now.replace(hour=20, minute=00, second=0)
                elif arg == "-F":
                        mode = "Flowering"
                        TurnOn = now.replace(hour=8, minute=00, second=0)
                        TurnOff = now.replace(hour=20, minute=00, second=0)
                elif arg == "-v" or arg == "-V":
                        mode = "Vegetative"
                        TurnOn = now.replace(hour=8, minute=00, second=0)
                        TurnOff = now.replace(hour=20, minute=00, second=0)
                elif arg == "-V":
                        mode = "Vegetative"
                        TurnOn = now.replace(hour=8, minute=00, second=0)
                        TurnOff = now.replace(hour=20, minute=00, second=0)
                elif arg == "-FF":
                        ForceFlood = "1"
                elif arg.isdigit():
                        period = arg
else:
        print "Usage: GrowBot6.sh -fF/-gG [Hour period] -FF "
        sys.exit()
GPIO.setmode(GPIO.BCM)      # set GPIO to board numbering
GPIO.setwarnings(False)
Pump = 15                  #Pump control is on pin 15 of the GPIO Header
Light = 18                 #Light control is on pin 15 of the GPIO Header
Fan = 21                   #Fan  control is on pin 15 of the GPIO Header
Air = 14
BedEnable = 17
BedSelect = 27
Drain = 22
Level = 0
GPIO.setup(Pump, GPIO.OUT)
GPIO.setup(Light, GPIO.OUT)
GPIO.setup(Air, GPIO.OUT)
GPIO.setup(BedEnable, GPIO.OUT)
GPIO.setup(BedSelect, GPIO.OUT)
GPIO.setup(Drain, GPIO.IN, pull_up_down = GPIO.PUD_DOWN)
pHSens = Sensor(99,1)
ECSens = Sensor(100,1)
pH = round(float(pHSens.query('R')), 3)
ECString = ECSens.query('R')
EC,TDS,Salt,SG=ECString.split(",")




now = datetime.datetime.now()
#FloodTimer = Timer(3600.0, WaterIt)
#FloodTimer.start() #Strart after 3600 sec (1h)
while True:
	now = datetime.datetime.now()
	readDB()
	LightIt(TurnOn, TurnOff)
	time.sleep(3)
	os.system('clear')
	WaterIt(Level, period, NextFlood)
	#WriteDB("08:29:00","12:29:00","5","08:00:00","08:45:00","01.010")

